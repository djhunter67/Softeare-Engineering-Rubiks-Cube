# -*- org-confirm-babel-evaluate: nil -*-
#+AUTHOR: Christerpher Hunter
#+EMAIL: djhunter67@gmail.com
#+OPTIONS: toc:nil todo:nil  num:nil title:nil
#+LATEX_HEADER:\usepackage{mathptmx}
#+LATEX_HEADER: \usepackage[letterpaper,top=1in, bottom=1in, left=1.5in, right=1in]{geometry}
#+LATEX_HEADER: \usepackage[round]{natbib}
#+LATEX_HEADER: \usepackage{setspace}
#+LATEX_HEADER: \doublespacing
#+LATEX_HEADER:\pagenumbering{Roman}
#+LATEX_HEADER:\usepackage{scrlayer-scrpage}

\begin{titlepage}
\begin{center}
\vspace{2cm}
{\huge  Rubikan Design \par}
\vspace{2cm}
by \par
\vspace{0cm}
{\Large Christerpher Hunter \par}
\vfill
Nova Southeaster University\\
{\small \today  \par}
\end{center}
\end{titlepage}


* Design

** Startup

#+BEGIN_SRC plantuml :file startup_design.png

         scale 600

   class Initialize {
      -private OScheck 
      -private user_name

      --
    
      +present_GUI()
      +get_OS()
      }

    class OSCheck {
  +check_OS()
  +check_num_displays()
  }

    class Username {
    +prompt_username()
    +show_username()
  }

        Initialize <--> OSCheck
        Initialize <--> Username

#+END_SRC

#+RESULTS:
[[file:startup_design.png]]

\newpage
The purpose of the class Initialize is to launch the GUI window, get the username from the user (similar to an Arcade), and check the operating system.  The GUI window will present the Standby State presented in the next diagram.  The username function will prompt the user for a name to use when commiting scores.  The operating system check will get the name of the operating system and which distribution, if necessary.\\

The intent of having a module to display the GUI before the module that contains the buttons and actions is due to the manner of implementation of the GUI operation.  The idea here is to set up the frame and backdrop for the application first and then load the features afterward.  This will allow future enhancement of the application to be simpler.  The Standby State will reside in waiting and then immediately load into the Initialization class without delay.  This is due to a fluid and manipulative design.\\

The class Username is used in several places throughout the application in order to keep track of scores.  Each completed attempt will be coupled with a time and a username.  The username in, every instance, will be provided by class Username.  The class Username will prompt the user at the beginning of each launch of the application.  Another user, at any time during the Stanby State, can add a new username.  Upon the completion of a game, if there are two or more usernames, a confirmation prompt with the time and the username list will be shown.  The present user will need to choose, or optionally, enter a username; this is required to enter a winning time into the database.\\

The class OSCheck is intended to get the name and version of the operating system from which the application launches.  Should the operating system come back as a Linux operating system the class OSCheck will then attain the specfic distribution.  The purpose of checking the operating is two fold.  Firstly, the class MultiMonitor will communicate to the class OSCheck to obtain the operating system; this is needed for the class MultiMonitor to function as expected.  Secondly, to appropriately display the application and its popups the manner in which frames are displayed must be ascertained and is directly related to the operating system the application launches from.\\

\newpage
** Standby State
#+BEGIN_SRC plantuml :file main_design.png

        scale 600
        
      package SplashScreen <<Node>> {
        class Main {
        +controls_GUI()
        }
        class Cube {}
        class Username {}  
        <> diamond
      package Controls {
      class Start {
    -private get_state	 
    ==
    +start_game()
      }
      class TimeAttack {
    -private get_state
    #protected delay_time
    ==
       +check_for_times()
       +start_timer()
       +start_game()
      }
      class Compass {
    -private card_directions
    -private compass_img
    -private get_state
    ==      
    +show_scores()
    +show_algorithms()	
      }
      class Quit {
    +exit_app()
      }
    }
        }
        package Models <<Database>>{
        class DataBase {} 
        }

       Main -- diamond
       diamond -- Start
       diamond -- TimeAttack
       diamond -- Compass
       diamond -- Quit
     hide @unlinked


#+END_SRC

#+RESULTS:
[[file:main_design.png]]
\newpage

The splash screen serves as a template for which all non-timed activities are available and accomplishable.  The class Main has one method, controls_GUI(), that communicates with the Controls module.  In the Controls module there exists four control classes.  The class Compass is a clickable button that pops up a window displaying the previous times and username that reside in the database.  The class TimeAttack is similar to the start button in that it deactivates other buttons and moves the application from the Standby State to the Time-Attack State.  The class Start will initiate a normal game, deactivate other buttons, and move the application from the Standby State to the Active State.  The class Quit is design to exit the application at anytime during any state.\\

The class Main has no variables or constants and one method.  The controls_GUI method calls any one of the selected classes presented in the Standby State to the user.  The class that is executed is the choice the user makes.  The options in the choice are Start, Time-Attack, Compass, and Quit.  


\newpage
** Active State
#+BEGIN_SRC plantuml :file game_design.png

        scale 600

        package "Active Game" as AG {
           class Start {
           -private get_state	 
           ==
           +start_game()	
           }
           class Username {
           +present_username()
           }  
           class Restart {}
           class Reset {}
               class Timer {}
           class Selection {}
           class Rotate {}
           class Controls {}
           class Quit {}
                <> diamond
  }
           package Models <<Database>>{
           class DataBase {} 
           }

    package "Won Game" as WG {
           class Completed {}
         }


          Start . diamond
          diamond - Selection
          diamond --> DataBase
          diamond --> Controls
              diamond --> Restart
          Controls <--> Rotate
          Restart --> Reset
            Timer --> diamond
        Start <-- Username
        AG +--> WG
     Completed  --> DataBase
   hide @unlinked




#+END_SRC

#+RESULTS:
[[file:game_design.png]]

\newpage
** Time-Attack State

#+BEGIN_SRC plantuml :file time-attack_design.png

     scale 600
   package TimeAttackMode {
   class TimeAttack {}
       class Controls {}
      class Selection {}
    class Username {}
        class Timer {}
      class Rotate {}
  class Quit {}
     }
       package Models <<Database>> {
             class DataBase {}
           }
         package Won {
          class Completed {}
       }


       TimeAttack <-- Username
       TimeAttack <-- Timer
       TimeAttack --> Controls
       Controls --> Selection
       Controls --> Rotate
       Models --> TimeAttack
       Timer --|> Quit
       TimeAttackMode +---> Won
     Won ---> Models


#+END_SRC

#+RESULTS:
[[file:time-attack_architecture.png]]

\newpage
** Data-centered Architecture

#+BEGIN_SRC plantuml :file data_design.png

  scale 600
  database "sqlite3" 

  frame "class Initialize" as f1
  frame "class Username" as f2
  frame "class TimeAttack" as f5
  frame "class Comparison" as f6
  frame "class Completed" as f7
  frame "class Compass" as f9
  frame "class Scores" as f10

      sqlite3 <-left-> f1
      sqlite3 <-right-> f2
      sqlite3 <--> f5
      sqlite3 <--> f6
      sqlite3 <-up-> f7
      sqlite3 <-up-> f9
      sqlite3 <-up-> f10


#+END_SRC

#+RESULTS:
[[file:data_architecture.png]]
